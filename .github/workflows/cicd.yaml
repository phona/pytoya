name: CI/CD

on:
  push:
  pull_request:
  workflow_dispatch:
    inputs:
      base_path:
        description: 'Optional base path (example: /pytoya). Defaults to vars.BASE_PATH or empty.'
        type: string
        required: false
        default: ''

permissions:
  contents: read

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: false

env:
  GHCR_IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  API_IMAGE: pytoya/api
  WEB_IMAGE: pytoya/web
  DEFAULT_NAMESPACE: pytoya
  DEFAULT_RELEASE_NAME: pytoya

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Type Check
        run: npm run type-check

      - name: Test (API)
        run: npm run test --workspace=@pytoya/api

      - name: Test + Coverage Gates (Web)
        run: npm run test:coverage --workspace=@pytoya/web

  build_and_push:
    runs-on: ubuntu-latest
    needs: ci
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_name == 'master') }}
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.vars.outputs.image_tag }}
      vite_api_url: ${{ steps.vars.outputs.vite_api_url }}
      vite_base_path: ${{ steps.vars.outputs.vite_base_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute tags and build args
        id: vars
        shell: bash
        env:
          RAW_BASE_PATH: ${{ github.event.inputs.base_path || vars.BASE_PATH || '' }}
        run: |
          set -euo pipefail

          image_tag="${GITHUB_SHA:0:12}"

          raw_base_path="$(echo "${RAW_BASE_PATH:-}" | xargs)"
          if [[ -z "${raw_base_path}" || "${raw_base_path}" == "/" ]]; then
            vite_base_path=""
          else
            vite_base_path="${raw_base_path}"
            [[ "${vite_base_path}" == /* ]] || vite_base_path="/${vite_base_path}"
            vite_base_path="${vite_base_path%/}"
          fi

          if [[ -n "${vite_base_path}" ]]; then
            vite_api_url="${vite_base_path}/api"
          else
            vite_api_url="/api"
          fi

          echo "image_tag=${image_tag}" >> "${GITHUB_OUTPUT}"
          echo "vite_base_path=${vite_base_path}" >> "${GITHUB_OUTPUT}"
          echo "vite_api_url=${vite_api_url}" >> "${GITHUB_OUTPUT}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Build and push API image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/apps/api/Dockerfile
          push: true
          tags: |
            ${{ env.GHCR_IMAGE_REGISTRY }}/${{ env.API_IMAGE }}:${{ steps.vars.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Web image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/apps/web/Dockerfile
          push: true
          build-args: |
            VITE_API_URL=${{ steps.vars.outputs.vite_api_url }}
            VITE_BASE_PATH=${{ steps.vars.outputs.vite_base_path }}
          tags: |
            ${{ env.GHCR_IMAGE_REGISTRY }}/${{ env.WEB_IMAGE }}:${{ steps.vars.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_name == 'master') }}
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Install Helm
        uses: azure/setup-helm@v4

      - name: Configure kubeconfig
        shell: bash
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -euo pipefail
          if [[ -z "${KUBE_CONFIG:-}" ]]; then
            echo "Missing secrets.KUBE_CONFIG (base64 kubeconfig or raw kubeconfig YAML)." >&2
            exit 2
          fi
          mkdir -p "${HOME}/.kube"
          if echo "${KUBE_CONFIG}" | head -n 1 | grep -qE '^apiVersion:'; then
            printf "%s" "${KUBE_CONFIG}" > "${HOME}/.kube/config"
          else
            echo "${KUBE_CONFIG}" | base64 -d > "${HOME}/.kube/config"
          fi

      - name: Deploy via Helm
        shell: bash
        env:
          RAW_BASE_PATH: ${{ github.event.inputs.base_path || vars.BASE_PATH || '' }}
          NAMESPACE: ${{ secrets.K8S_NAMESPACE || env.DEFAULT_NAMESPACE }}
          RELEASE_NAME: ${{ secrets.K8S_RELEASE_NAME || env.DEFAULT_RELEASE_NAME }}
          IMAGE_TAG: ${{ needs.build_and_push.outputs.image_tag }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'pytoya' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'pytoya' }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          # Optional: if your cluster cannot pull from GHCR anonymously, set this to an existing imagePullSecret name.
          K8S_IMAGE_PULL_SECRET_NAME: ${{ secrets.K8S_IMAGE_PULL_SECRET_NAME }}
        run: |
          set -euo pipefail

          if [[ -z "${POSTGRES_PASSWORD:-}" ]]; then echo "Missing secrets.POSTGRES_PASSWORD" >&2; exit 2; fi
          if [[ -z "${JWT_SECRET:-}" ]]; then echo "Missing secrets.JWT_SECRET" >&2; exit 2; fi

          raw_base_path="$(echo "${RAW_BASE_PATH:-}" | xargs)"
          if [[ -z "${raw_base_path}" || "${raw_base_path}" == "/" ]]; then
            base_path=""
          else
            base_path="${raw_base_path}"
            [[ "${base_path}" == /* ]] || base_path="/${base_path}"
            base_path="${base_path%/}"
          fi

          # Derive chart fullname to match `helm/pytoya/templates/_helpers.tpl`.
          # If release name already contains `pytoya`, fullname is the release name; otherwise it's `${release}-pytoya`.
          if [[ "${RELEASE_NAME}" == *pytoya* ]]; then
            fullname="${RELEASE_NAME}"
          else
            fullname="${RELEASE_NAME}-pytoya"
          fi

          postgres_host="${fullname}-postgres"
          redis_host="${fullname}-redis"

          extra_set_args=()
          if [[ -n "${K8S_IMAGE_PULL_SECRET_NAME:-}" ]]; then
            extra_set_args+=(--set "global.imagePullSecrets[0]=${K8S_IMAGE_PULL_SECRET_NAME}")
          fi

          echo "Deploying ${RELEASE_NAME} to namespace=${NAMESPACE} tag=${IMAGE_TAG} basePath='${base_path}'"

          helm upgrade --install "${RELEASE_NAME}" helm/pytoya \
            --namespace "${NAMESPACE}" \
            --create-namespace \
            --set "global.imageRegistry=${GHCR_IMAGE_REGISTRY}" \
            --set "global.basePath=${base_path}" \
            --set "api.tag=${IMAGE_TAG}" \
            --set "web.tag=${IMAGE_TAG}" \
            --set "postgres.auth.password=${POSTGRES_PASSWORD}" \
            --set "postgres.auth.username=${POSTGRES_USER}" \
            --set "postgres.auth.database=${POSTGRES_DB}" \
            --set "secrets.jwtSecret=${JWT_SECRET}" \
            --set "api.config.database.host=${postgres_host}" \
            --set "api.config.database.username=${POSTGRES_USER}" \
            --set "api.config.database.database=${POSTGRES_DB}" \
            --set "api.config.redis.host=${redis_host}" \
            "${extra_set_args[@]}" \
            --wait \
            --timeout 10m

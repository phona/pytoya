name: CI/CD

on:
  push:
  pull_request:
  workflow_dispatch:
    inputs:
      ingress_host:
        description: 'Ingress host (example: pytoya.example.com). Defaults to vars.INGRESS_HOST or secrets.K8S_INGRESS_HOST.'
        type: string
        required: false
        default: ''

permissions:
  contents: read

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: false

env:
  GHCR_IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  API_IMAGE: pytoya/api
  WEB_IMAGE: pytoya/web
  DEFAULT_NAMESPACE: pytoya
  DEFAULT_RELEASE_NAME: pytoya

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Type Check
        run: npm run type-check

      - name: Test (API)
        run: npm run test --workspace=@pytoya/api

      - name: Test + Coverage Gates (Web)
        run: npm run test:coverage --workspace=@pytoya/web

  build_and_push:
    runs-on: ubuntu-latest
    needs: ci
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_name == 'master') }}
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.vars.outputs.image_tag }}
      vite_api_url: ${{ steps.vars.outputs.vite_api_url }}
      chart_version: ${{ steps.vars.outputs.chart_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute tags and build args
        id: vars
        shell: bash
        run: |
          set -euo pipefail

          image_tag="${GITHUB_SHA:0:12}"
          vite_api_url="/api"
          chart_version="0.1.0-${image_tag}"

          echo "image_tag=${image_tag}" >> "${GITHUB_OUTPUT}"
          echo "vite_api_url=${vite_api_url}" >> "${GITHUB_OUTPUT}"
          echo "chart_version=${chart_version}" >> "${GITHUB_OUTPUT}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Build and push API image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/apps/api/Dockerfile
          push: true
          tags: |
            ${{ env.GHCR_IMAGE_REGISTRY }}/${{ env.API_IMAGE }}:${{ steps.vars.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Web image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/apps/web/Dockerfile
          push: true
          build-args: |
            VITE_API_URL=${{ steps.vars.outputs.vite_api_url }}
          tags: |
            ${{ env.GHCR_IMAGE_REGISTRY }}/${{ env.WEB_IMAGE }}:${{ steps.vars.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Package and push Helm chart (OCI)
        shell: bash
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}
          IMAGE_TAG: ${{ steps.vars.outputs.image_tag }}
          CHART_VERSION: ${{ steps.vars.outputs.chart_version }}
        run: |
          set -euo pipefail

          echo "${GHCR_TOKEN}" | helm registry login ghcr.io -u "${GITHUB_ACTOR}" --password-stdin

          mkdir -p .artifacts
          helm package helm/pytoya \
            --destination .artifacts \
            --version "${CHART_VERSION}" \
            --app-version "${IMAGE_TAG}"

          chart_tgz="$(ls -1 .artifacts/*.tgz | head -n 1)"
          echo "Pushing ${chart_tgz} -> oci://${GHCR_IMAGE_REGISTRY}/charts"
          helm push "${chart_tgz}" "oci://${GHCR_IMAGE_REGISTRY}/charts"

  deploy:
    runs-on: [self-hosted, linux]
    needs: build_and_push
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_name == 'master') }}
    environment: production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Deploy debug (safe context + kube probes)
        shell: bash
        run: |
          set -euo pipefail

          echo "Runner: name='${RUNNER_NAME:-}' os='${RUNNER_OS:-}' arch='${RUNNER_ARCH:-}'"
          echo "GitHub: repo='${GITHUB_REPOSITORY:-}' ref='${GITHUB_REF:-}' ref_name='${GITHUB_REF_NAME:-}' sha='${GITHUB_SHA:-}' actor='${GITHUB_ACTOR:-}'"
          echo "Workspace: '${GITHUB_WORKSPACE:-}'"
          echo "KUBECONFIG: '${KUBECONFIG:-<default>}'"
          if [[ -n "${KUBECONFIG:-}" ]]; then
            ls -la "${KUBECONFIG}" || true
          fi

          echo "--- kubectl config (safe) ---"
          kubectl config current-context || true
          cluster="$(kubectl config view --minify -o jsonpath='{.contexts[0].context.cluster}' 2>/dev/null || true)"
          user="$(kubectl config view --minify -o jsonpath='{.contexts[0].context.user}' 2>/dev/null || true)"
          server="$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || true)"
          ns="$(kubectl config view --minify -o jsonpath='{.contexts[0].context.namespace}' 2>/dev/null || true)"
          echo "kube.cluster=${cluster:-<unknown>}"
          echo "kube.user=${user:-<unknown>}"
          echo "kube.namespace=${ns:-<default>}"
          echo "kube.server=${server:-<unknown>}"

          echo "--- apiserver probes (best-effort) ---"
          kubectl get --raw='/version' 2>/dev/null | head -c 400 || true
          echo
          kubectl get --raw='/healthz' 2>/dev/null | head -c 200 || true
          echo
          if command -v curl >/dev/null 2>&1 && [[ -n "${server:-}" ]]; then
            server="${server%/}"
            echo "--- curl ${server}/version (unauthenticated) ---"
            curl -skS -o /dev/null -w "http_status=%{http_code} time_total=%{time_total}\n" "${server}/version" || true
          fi

      - name: Verify kubectl + helm present
        shell: bash
        run: |
          set -euo pipefail
          command -v kubectl >/dev/null 2>&1 || { echo "kubectl not found on runner" >&2; exit 2; }
          command -v helm >/dev/null 2>&1 || { echo "helm not found on runner" >&2; exit 2; }
          kubectl version --client=true
          helm version

      - name: Deploy via Helm
        shell: bash
        env:
          INGRESS_HOST: ${{ github.event.inputs.ingress_host || vars.INGRESS_HOST || secrets.K8S_INGRESS_HOST || '' }}
          INGRESS_TLS_SECRET_NAME: ${{ vars.INGRESS_TLS_SECRET_NAME || secrets.K8S_INGRESS_TLS_SECRET_NAME || '' }}
          NAMESPACE: ${{ secrets.K8S_NAMESPACE || env.DEFAULT_NAMESPACE }}
          RELEASE_NAME: ${{ secrets.K8S_RELEASE_NAME || env.DEFAULT_RELEASE_NAME }}
          IMAGE_TAG: ${{ needs.build_and_push.outputs.image_tag }}
          CHART_VERSION: ${{ needs.build_and_push.outputs.chart_version }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'pytoya' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'pytoya' }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}
          # Optional: if your cluster cannot pull from GHCR anonymously, set this to an existing imagePullSecret name.
          K8S_IMAGE_PULL_SECRET_NAME: ${{ secrets.K8S_IMAGE_PULL_SECRET_NAME }}
        run: |
          set -euo pipefail

          if [[ -z "${INGRESS_HOST:-}" ]]; then echo "Missing ingress host. Set workflow input 'ingress_host' or define vars.INGRESS_HOST / secrets.K8S_INGRESS_HOST." >&2; exit 2; fi
          if [[ -z "${POSTGRES_PASSWORD:-}" ]]; then echo "Missing secrets.POSTGRES_PASSWORD" >&2; exit 2; fi
          if [[ -z "${JWT_SECRET:-}" ]]; then echo "Missing secrets.JWT_SECRET" >&2; exit 2; fi
          if [[ -z "${CHART_VERSION:-}" ]]; then echo "Missing chart version from build job output." >&2; exit 2; fi

          echo "${GHCR_TOKEN}" | helm registry login ghcr.io -u "${GITHUB_ACTOR}" --password-stdin

          # Derive chart fullname to match `helm/pytoya/templates/_helpers.tpl`.
          # If release name already contains `pytoya`, fullname is the release name; otherwise it's `${release}-pytoya`.
          if [[ "${RELEASE_NAME}" == *pytoya* ]]; then
            fullname="${RELEASE_NAME}"
          else
            fullname="${RELEASE_NAME}-pytoya"
          fi

          postgres_host="${fullname}-postgres"
          redis_host="${fullname}-redis"

          extra_set_args=()
          if [[ -n "${K8S_IMAGE_PULL_SECRET_NAME:-}" ]]; then
            extra_set_args+=(--set "global.imagePullSecrets[0]=${K8S_IMAGE_PULL_SECRET_NAME}")
          fi
          if [[ -n "${INGRESS_TLS_SECRET_NAME:-}" ]]; then
            extra_set_args+=(--set "ingress.tls[0].hosts[0]=${INGRESS_HOST}")
            extra_set_args+=(--set "ingress.tls[0].secretName=${INGRESS_TLS_SECRET_NAME}")
          fi

          echo "Deploying ${RELEASE_NAME} to namespace=${NAMESPACE} tag=${IMAGE_TAG} host='${INGRESS_HOST}'"

          helm upgrade --install "${RELEASE_NAME}" "oci://${GHCR_IMAGE_REGISTRY}/charts/pytoya" \
            --version "${CHART_VERSION}" \
            --namespace "${NAMESPACE}" \
            --create-namespace \
            --set "global.imageRegistry=${GHCR_IMAGE_REGISTRY}" \
            --set "api.tag=${IMAGE_TAG}" \
            --set "web.tag=${IMAGE_TAG}" \
            --set "ingress.className=traefik" \
            --set "ingress.annotations.kubernetes\\.io/ingress\\.class=traefik" \
            --set "ingress.hosts[0]=${INGRESS_HOST}" \
            --set "postgres.auth.password=${POSTGRES_PASSWORD}" \
            --set "postgres.auth.username=${POSTGRES_USER}" \
            --set "postgres.auth.database=${POSTGRES_DB}" \
            --set "secrets.jwtSecret=${JWT_SECRET}" \
            --set "api.config.database.host=${postgres_host}" \
            --set "api.config.database.username=${POSTGRES_USER}" \
            --set "api.config.database.database=${POSTGRES_DB}" \
            --set "api.config.redis.host=${redis_host}" \
            "${extra_set_args[@]}" \
            --wait \
            --timeout 10m

      - name: Deploy debug (on failure)
        if: ${{ failure() }}
        shell: bash
        env:
          NAMESPACE: ${{ secrets.K8S_NAMESPACE || env.DEFAULT_NAMESPACE }}
          RELEASE_NAME: ${{ secrets.K8S_RELEASE_NAME || env.DEFAULT_RELEASE_NAME }}
        run: |
          set +e
          echo "--- versions ---"
          kubectl version --short
          helm version

          echo "--- cluster-info ---"
          kubectl cluster-info

          echo "--- namespace (${NAMESPACE}) ---"
          kubectl get ns "${NAMESPACE}" -o wide

          echo "--- pods (${NAMESPACE}) ---"
          kubectl get pods -n "${NAMESPACE}" -o wide

          echo "--- helm status (${RELEASE_NAME}) ---"
          helm status "${RELEASE_NAME}" -n "${NAMESPACE}"

          echo "--- helm history (${RELEASE_NAME}) ---"
          helm history "${RELEASE_NAME}" -n "${NAMESPACE}" --max 10

name: CI/CD

# ==============================================================================
# GitHub Secrets Configuration
# ==============================================================================
# Required Secrets (for private registry):
#   REGISTRY_URL           - Your container registry URL (e.g., registry.example.com)
#   REGISTRY_USERNAME      - Registry username
#   REGISTRY_PASSWORD      - Registry password or access token
#
# Optional Secrets:
#   REGISTRY_HOST_ENTRY    - /etc/hosts entry for custom registry (format: "IP hostname")
#   HELM_CHART_URL         - Direct Helm chart URL (skips chart push if set)
#   K8S_NAMESPACE          - Kubernetes namespace (default: pytoya)
#   K8S_RELEASE_NAME       - Helm release name (default: pytoya)
#
# Note: Database, Redis, JWT, and Ingress settings are configured via
#       /home/github-runner/pytoya.values.yaml on the self-hosted runner.
# ==============================================================================

on:
  push:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: false

env:
  # Use private registry if configured, otherwise fall back to GHCR
  IMAGE_REGISTRY: ${{ secrets.REGISTRY_URL || format('ghcr.io/{0}', github.repository_owner) }}
  # Optional: /etc/hosts entry for a custom registry (format: "IP hostname")
  REGISTRY_HOST_ENTRY: ${{ secrets.REGISTRY_HOST_ENTRY }}
  API_IMAGE: pytoya/api
  WEB_IMAGE: pytoya/web
  DEFAULT_NAMESPACE: pytoya
  DEFAULT_RELEASE_NAME: pytoya

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Type Check
        run: npm run type-check

      - name: Test (API)
        run: npm run test --workspace=@pytoya/api

      - name: Test + Coverage Gates (Web)
        run: npm run test:coverage --workspace=@pytoya/web

  build_images:
    runs-on: ubuntu-latest
    needs: ci
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_name == 'master') }}
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.vars.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - name: api
            dockerfile: src/apps/api/Dockerfile
            image: pytoya/api
          - name: web
            dockerfile: src/apps/web/Dockerfile
            image: pytoya/web
            build_args: VITE_API_URL=/api
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute tags
        id: vars
        shell: bash
        run: |
          image_tag="${GITHUB_SHA:0:12}"
          echo "image_tag=${image_tag}" >> "${GITHUB_OUTPUT}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Add registry to /etc/hosts
        if: ${{ env.REGISTRY_HOST_ENTRY != '' }}
        shell: bash
        run: |
          echo "${REGISTRY_HOST_ENTRY}" | sudo tee -a /etc/hosts

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY_URL || 'ghcr.io' }}
          username: ${{ secrets.REGISTRY_USERNAME || github.actor }}
          password: ${{ secrets.REGISTRY_PASSWORD || secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Build and push ${{ matrix.name }} image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          push: true
          build-args: ${{ matrix.build_args || '' }}
          tags: |
            ${{ secrets.REGISTRY_URL || format('ghcr.io/{0}', github.repository_owner) }}/${{ matrix.image }}:${{ steps.vars.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  push_helm_chart:
    runs-on: ubuntu-latest
    needs: [ci, build_images]
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_name == 'master') }}
    permissions:
      contents: read
      packages: write
    outputs:
      chart_version: ${{ steps.vars.outputs.chart_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute chart version
        id: vars
        shell: bash
        run: |
          image_tag="${GITHUB_SHA:0:12}"
          chart_version="0.1.0-${image_tag}"
          echo "chart_version=${chart_version}" >> "${GITHUB_OUTPUT}"

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Add registry to /etc/hosts
        if: ${{ env.REGISTRY_HOST_ENTRY != '' }}
        shell: bash
        run: |
          echo "${REGISTRY_HOST_ENTRY}" | sudo tee -a /etc/hosts

      - name: Package and push Helm chart (OCI)
        shell: bash
        env:
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD || secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME || github.actor }}
          REGISTRY_URL: ${{ secrets.REGISTRY_URL || 'ghcr.io' }}
          IMAGE_TAG: ${{ needs.build_images.outputs.image_tag }}
          CHART_VERSION: ${{ steps.vars.outputs.chart_version }}
          HELM_CHART_URL: ${{ secrets.HELM_CHART_URL }}
        run: |
          set -euo pipefail

          # Skip Helm chart push if HELM_CHART_URL is provided (user manages chart externally)
          if [[ -n "${HELM_CHART_URL:-}" ]]; then
            echo "HELM_CHART_URL is set. Skipping Helm chart push (chart managed externally)."
            exit 0
          fi

          echo "${REGISTRY_PASSWORD}" | helm registry login "${REGISTRY_URL}" -u "${REGISTRY_USERNAME}" --password-stdin

          mkdir -p .artifacts
          helm package helm/pytoya \
            --destination .artifacts \
            --version "${CHART_VERSION}" \
            --app-version "${IMAGE_TAG}"

          chart_tgz="$(ls -1 .artifacts/*.tgz | head -n 1)"
          echo "Pushing ${chart_tgz} -> oci://${REGISTRY_URL}/charts"
          helm push "${chart_tgz}" "oci://${REGISTRY_URL}/charts"

  deploy:
    runs-on: [self-hosted, linux]
    needs: [build_images, push_helm_chart]
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref_name == 'master') }}
    environment: production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Deploy debug (safe context + kube probes)
        shell: bash
        run: |
          set -euo pipefail

          echo "Runner: name='${RUNNER_NAME:-}' os='${RUNNER_OS:-}' arch='${RUNNER_ARCH:-}'"
          echo "GitHub: repo='${GITHUB_REPOSITORY:-}' ref='${GITHUB_REF:-}' ref_name='${GITHUB_REF_NAME:-}' sha='${GITHUB_SHA:-}' actor='${GITHUB_ACTOR:-}'"
          echo "Workspace: '${GITHUB_WORKSPACE:-}'"
          echo "KUBECONFIG: '${KUBECONFIG:-<default>}'"
          if [[ -n "${KUBECONFIG:-}" ]]; then
            ls -la "${KUBECONFIG}" || true
          fi

          echo "--- kubectl config (safe) ---"
          kubectl config current-context || true
          cluster="$(kubectl config view --minify -o jsonpath='{.contexts[0].context.cluster}' 2>/dev/null || true)"
          user="$(kubectl config view --minify -o jsonpath='{.contexts[0].context.user}' 2>/dev/null || true)"
          server="$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || true)"
          ns="$(kubectl config view --minify -o jsonpath='{.contexts[0].context.namespace}' 2>/dev/null || true)"
          echo "kube.cluster=${cluster:-<unknown>}"
          echo "kube.user=${user:-<unknown>}"
          echo "kube.namespace=${ns:-<default>}"
          echo "kube.server=${server:-<unknown>}"

          echo "--- apiserver probes (best-effort) ---"
          kubectl get --raw='/version' 2>/dev/null | head -c 400 || true
          echo
          kubectl get --raw='/healthz' 2>/dev/null | head -c 200 || true
          echo
          if command -v curl >/dev/null 2>&1 && [[ -n "${server:-}" ]]; then
            server="${server%/}"
            echo "--- curl ${server}/version (unauthenticated) ---"
            curl -skS -o /dev/null -w "http_status=%{http_code} time_total=%{time_total}\n" "${server}/version" || true
          fi

      - name: Verify kubectl + helm present
        shell: bash
        run: |
          set -euo pipefail
          command -v kubectl >/dev/null 2>&1 || { echo "kubectl not found on runner" >&2; exit 2; }
          command -v helm >/dev/null 2>&1 || { echo "helm not found on runner" >&2; exit 2; }
          kubectl version --client=true
          helm version

      - name: Add registry to /etc/hosts
        if: ${{ env.REGISTRY_HOST_ENTRY != '' }}
        shell: bash
        run: |
          echo "${REGISTRY_HOST_ENTRY}" | sudo tee -a /etc/hosts

      - name: Deploy via Helm
        shell: bash
        env:
          NAMESPACE: ${{ secrets.K8S_NAMESPACE || env.DEFAULT_NAMESPACE }}
          RELEASE_NAME: ${{ secrets.K8S_RELEASE_NAME || env.DEFAULT_RELEASE_NAME }}
          IMAGE_REGISTRY: ${{ secrets.REGISTRY_URL || format('ghcr.io/{0}', github.repository_owner) }}
          IMAGE_TAG: ${{ needs.build_images.outputs.image_tag }}
          CHART_VERSION: ${{ needs.push_helm_chart.outputs.chart_version }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD || secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME || github.actor }}
          HELM_CHART_URL: ${{ secrets.HELM_CHART_URL }}
        run: |
          set -euo pipefail

          server_values_file="/home/github-runner/pytoya.values.yaml"
          if [[ ! -f "${server_values_file}" ]]; then
            echo "Server values file not found: ${server_values_file}"
            echo "Skipping Helm deployment."
            exit 0
          fi

          # Determine Helm chart URL
          if [[ -n "${HELM_CHART_URL:-}" ]]; then
            chart_url="${HELM_CHART_URL}"
          else
            echo "${REGISTRY_PASSWORD}" | helm registry login "${IMAGE_REGISTRY}" -u "${REGISTRY_USERNAME}" --password-stdin
            chart_url="oci://${IMAGE_REGISTRY}/charts/pytoya"
            if [[ -z "${CHART_VERSION:-}" ]]; then echo "Missing chart version from build job output (required for OCI registry)." >&2; exit 2; fi
          fi

          echo "Using server values file: ${server_values_file}"
          echo "Deploying ${RELEASE_NAME} to namespace=${NAMESPACE} tag=${IMAGE_TAG}"
          echo "Image registry: ${IMAGE_REGISTRY}"
          echo "Helm chart: ${chart_url}"

          helm_args=(
            --upgrade
            --install "${RELEASE_NAME}" "${chart_url}"
          )

          # Only add --version if pulling from OCI registry (not for direct chart URLs)
          if [[ "${chart_url}" == oci://* ]]; then
            helm_args+=(--version "${CHART_VERSION}")
          fi

          helm_args+=(
            -f "${server_values_file}"
            --namespace "${NAMESPACE}"
            --create-namespace
            --set "api.image=${IMAGE_REGISTRY}/${API_IMAGE}"
            --set "api.tag=${IMAGE_TAG}"
            --set "worker.image=${IMAGE_REGISTRY}/${API_IMAGE}"
            --set "worker.tag=${IMAGE_TAG}"
            --set "web.image=${IMAGE_REGISTRY}/${WEB_IMAGE}"
            --set "web.tag=${IMAGE_TAG}"
            --wait
            --timeout 10m
          )

          helm "${helm_args[@]}"

      - name: Deploy debug (on failure)
        if: ${{ failure() }}
        shell: bash
        env:
          NAMESPACE: ${{ secrets.K8S_NAMESPACE || env.DEFAULT_NAMESPACE }}
          RELEASE_NAME: ${{ secrets.K8S_RELEASE_NAME || env.DEFAULT_RELEASE_NAME }}
        run: |
          set +e
          echo "--- versions ---"
          kubectl version --client=true
          helm version

          echo "--- cluster-info ---"
          kubectl cluster-info

          echo "--- namespace (${NAMESPACE}) ---"
          kubectl get ns "${NAMESPACE}" -o wide

          echo "--- pods (${NAMESPACE}) ---"
          kubectl get pods -n "${NAMESPACE}" -o wide

          echo "--- helm status (${RELEASE_NAME}) ---"
          helm status "${RELEASE_NAME}" -n "${NAMESPACE}"

          echo "--- helm history (${RELEASE_NAME}) ---"
          helm history "${RELEASE_NAME}" -n "${NAMESPACE}" --max 10
